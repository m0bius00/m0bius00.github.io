---
title: "Black Hat Bash: Chapter 5 Exercise - FTP Vulnerability Scanner"
date: 2025-10-26 17:36:00
categories: [bhbash]
tags: [bhb]
math: false
image: /assets/img/scanresult.png
image_caption: Sample output of the FTP vulnerability scanner
---

## Introduction {: .h1 }

In this checkpoint, we'll solve one exercise from the *Black Hat Bash* book by Dolev Farhi and Nick Aleks. We would encounter more challenging exercises as we move through the book. We're currently on Chapter 5: Vulnerability Scanning and Fuzzing. This chapter introduces some essential tools of a Penetration Testing Process:

1. Nuclei
2. Nmap NSE Scripts
3. GitJacker for misconfigured git repositories on website endpoints
4. Wfuzz and ffuf (fuzz faster u fool) for sending semi-random payloads to websites to reveal covert information, often used for finding hidden web paths, directories, and files
5. Nikto for web vulnerability scanning

In the last of the chapter, as the format is observed, we are tasked with a challenging exercise. Let's try to solve this exercise with our knowledge and skills, even if the resultant is flawed, we tried at least, we can make it better!

## Exercise: Combining Tools to Find FTP Issues {: .h2 }

"The goal of this exercise is to write a script that calls several security tools, parses their output, and passes the output to other tools to act on it. Orchestrating multiple tools in this way is a common task in penetration testing, so we encourage you to get comfortable with building such workflows. Your script should do the following:

1. Accept one or more IP Addresses on the command line.
2. Run a port scanner against the IP address; which port scanner you use is completely up to you.
3. Identify open ports. If any of them are FTP Ports (21/TCP), the script should pass the address to the vulnerability scanner in step 4.
4. Use Nuclei to scan the IP Addresses and ports. Try applying templates dedicated to finding issues in FTP Servers. Search the Nuclei templates folder: ~/.local/nuclei-templates/ for FTP-related templates, or use the -tags ftp Nuclei flag.
5. Scan the IP Addresses with Nmap. Use NSE Scripts that find vulnerabilities in FTP Servers, which you can search for in the /usr/share/nmap/scripts/ directory. For example, try ftp-anon.nse
6. Parse and write the results to a file, in a format of your choice. The file should include description of the vulnerability, the relevant IP Address and port, the timestamp at which it was found, and the name of the tool that detected the issue. There is no hard requirement about how to present the data; one option is to use an HTML table. Alternatively you could write the results to a CSV File.

As you should know by now, there is more than one way to write such script. Only the end result matters, so craft the script as you see fit."

## My Script {: .h2 }

I attempted creating my script, I admit I ran into some logical and syntactical errors, but I debugged them. My script is as follows:

```bash

#!/usr/bin/env bash

if [[ "$#" == 0 ]]; then
  echo "You must provide an IP as an argument."
  exit 1
fi
for TARGET in $@; do
  if ! nc  ${TARGET} 21; then
    echo "[!] FTP Not Detected on Target: ${TARGET}"
    continue
  fi
  while read -r line; do
    ftp_port=$(echo "${line}" | grep "tcp" | awk -F'/' '{print $1}' | grep 21)
    if [[ $ftp_port  -eq 21 ]]; then
      echo "[!] FTP Found on Target: ${TARGET}"
      echo "[!] Running nuclei..."
      nuclei_result=$(nuclei -tags ftp -target "${TARGET}")
      echo "[!] Running NSE..."
      nse_result=$(nmap --script=ftp-anon.nse "${TARGET}")
      echo "[!] Writing to Log file: output_file.txt..."
      echo -e "#If A Target Result does not appear here, it means it does not use FTP, However The script would save Port Scan output. \n\nTarget: ${TARGET}\nTool: Nuclei\nFindings:\n$nuclei_result\n\nTool: Nmap NSE\n\nFindings:\n\n$nse_result\n" >> opfile.txt
    fi
  done < <(nmap -sS $TARGET)
done


<image-card alt="Script Output" src="/assets/img/scanresult.png" ></image-card>{ .border .rounded w:800 loading=lazy }
*Figure 1: Sample output from opfile.txt showing Nuclei and Nmap results.*

## Explanation {: .h2 }

- As you can see, the script first checks if there is any argument passed to the Command line, '$#' is a special bash variable that returns the total number of arguments passed to the script in an integer type.
- We run a for loop to iterate through the arguments. $@ is a special bash variable that contains all the arguments passed through the script (like in form of an array).
- For each Argument passed to the script, i.e. an IP Address of the target, we run a standard nmap SYN PORT SCAN.
- We check specifically if port 21 on that Target port is open or closed by connecting to it with netcat. We use command success evaluation with if command; then <expr> fi format
- If the FTP Port is closed, it prints FTP Not detected and skips the current iteration with the 'continue' command.
- If Port is open, it runs the consecutive block of the loop:
- The rest of the while loop is ran only if the FTP Port on the Target is open.
- Else we just print FTP Not detected.
- We use a while loop with Process Substitution (explained below) to format the workflow.
- We filter out the specific port required: 21/ftp with command substitution, and assign the value to the ftp_port variable.
- We then check if the ftp_port value is equal to 21 using Integer Operator -eq which stands for equals to.
- If there is a value, it prints FTP Port found.
- It runs nuclei with -tags ftp and -target flag and appends the output to the nuclei_result variable
- It then runs NSE and appends to output to nse_result variable.
- It then uses echo command with -e flag which allows us to interpret backslashes as escape sequences to print the output in a professional, greppable format in the opfile.txt
- The done < <(nmap -sS ${TARGET}) is a bash process substitution instruction that allows us to use a command as though it was a file. It runs the command on a stream which is represented by a file descriptor number which is a integer. For example: Lets suppose our nmap -sS scan runs on /dev/fd/3/ stream which looks like it is a directory. The output of the command stays in the /dev/fd/3/ directory and the loop reads from the stream as if reading from a file.
